!!Shortest path problem

The shortest path problem consists on finding a path between two pairs of nodes in which the sum
of the weights is minimized. For a general graph this problem is NP-hard. For some kind of graphs this problem
can be solved in linear time.

!!!Shortest path on unweighted graphs (BFS algorithm)

If the graph is unweighted or all edges have the same ""non-negative"" weight, the shortest path can be found
in linear time {{{$O(V + E)$}}} using Breadth First Search (BFS) algorithm.

BFS algorithm travels the graph in a traversal way.
BFS is a single source shortest path algorithm. That means that before running the algorithm it is needed
to specify a starting node. Then, the algorithm can tell us the shortest path between the starting node
and all the other nodes.

The algorithm is the following one:
[[[
initialize a queue Q
mark start node as visited
Q.enqueue(start)
while Q is not empty do:
  node := Q.dequeue()
  if node is the end then:
    return node
  for adjacent nodes of node do:
    if adjacentNode is not visited then:
      mark adjacentNode as visited
      Q.enqueue(adjacentNode)
]]]


In the Pharo implementation we use a linked list as a queue.

[[[
AIBFS>>#run

	| node neighbours |
	queue := LinkedList with: start.
	start visited: true.

	[ queue isNotEmpty ] whileTrue: [
		node := queue removeFirst.
		neighbours := node adjacentNodes.

		neighbours do: [ :next |
			next visited ifFalse: [
				queue addLast: next.
				next visited: true.
				next previousNode: node ] ] ]
]]]

After running the algorithm, to reconstruct the shortest path between the start and the end
node, we use the following method:

[[[
AIBFS>>#reconstructPath

	| path previous |
	"If no path exists between the start and the end node"
	end previousNode ifNil: [ ^ #(  ) ].
	path := LinkedList empty.
	previous := end.
	path addFirst: end model.
	[ previous = start ] whileFalse: [
		previous := previous previousNode.
		path addFirst: previous model ].
	^ path
]]]

!!!!Case study

+BFS graph>figures/bfs.pdf|width=45+

For the BFS graph, the shortest path can be calculated using the class ==AIBFS== like shown in the following example.

[[[
nodes := $a to: $i.
edges := #( #( $a $b ) #( $b $c ) #( $c $d ) #( $d $e ) #( $e $a )
            #( $b $e ) #( $e $b ) #( $e $f ) #( $f $g ) #( $g $h )
            #( $h $f ) #( $g $i ) #( $i $g ) ).
bfs := AIBFS new.
bfs
	nodes: nodes;
	edges: edges from: #first to: #second.

path := bfs runFrom: $a to: $g
]]]

The ==path== variable contains all the nodes that are part of the path, if we inspect the variable we see:
[[[
($a $b $e $f $g)
]]]

If we want to get the shortest path between the same starting node A and some other node, there is no need
of re-running the algorithm. We only need to change the end node and call the method reconstruct path.

[[[
bfs end: $d.
pathToD := bfs reconstructPath
]]]

!!!Shortest path on weighted graphs (Dijkstra's algorithm)

The Dijkstra's algorithm is one of the most-know algorithms for calculating the shortest path in a weighted graph.
As BFS, this algorithm is also a single source shortest path algorithm. In its naive implementation has a time
complexity of {{{$O(V^2)$}}}. But, it can be optimized using a head or a tree as a data structure to a time
complexity of {{{$O((V+E)*log V)$}}}. If a Fibonacci heap is used we can the best possible time complexity
{{{$O(E + V * log V)$}}}. Dijkstra's algorithm can handle a graph with cycles. But, it cannot handle negative weights.

The algorithm idea is:

[[[
1. Mark all nodes as unvisited.
2. Assign to every node infinity as the distance value. Set it to zero for the initial. Set the initial node as current.
3. Consider all of unvisited neighbours of the current node and calculate their distances through the current node. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one.
4. When all of the unvisited neighbours of the current node are checked, mark the current node as visited.
5. Select the unvisited node that is marked with the smallest tentative distance, set it as the new "current node", and go back to step 3.
]]]

Depending on the data structure that is chosen, the time complexity will vary. The array is the most inefficient one because to get the most
promising pair it is necessary to travel all the array {{{$O(N)$}}}. But on a heap, or a Fibonacci heap, the time complexity for getting
the most promising pair is in the logarithmic order.

The implementation in Pharo is the following:

[[[
AIDijkstra>>#run

	| pq |
	pq := self newPriorityQueue.
	pq add: start -> 0.

	[ pq isNotEmpty ] whileTrue: [
		| assoc node minWeight |
		assoc := self removeMostPromisingPair: pq.
		node := assoc key.
		minWeight := assoc value.
		"Do not visit again the node"
		node visited: true.

		"Skip if the path weight is less than the one obtained from the pq.
		This is an optimization for not processing unnecessary nodes."
		node pathDistance < minWeight ifFalse: [

			node outgoingEdges do: [ :edge |
				edge to visited ifFalse: [
					| newDistance |
					newDistance := node pathDistance + edge weight.

					newDistance < edge to pathDistance ifTrue: [
						edge to previousNode: node.
						edge to pathDistance: newDistance.
						pq add: edge to -> newDistance ] ] ] ] ]
]]]

!!!!Case study

+Dijkstra graph>figures/dijkstra.pdf|width=50+

In this graph, the shortest path between node A and B is ==#( $A $C $B )==
The shortest path between node A and node F is ==#( $A $C $B $D $E $F )==

[[[
nodes := $A to: $F.
edges := #( #( $A $B 5 ) #( $A $C 1 ) #( $B $C 2 ) #( $B $E 20 )
            #( $B $D 3 ) #( $C $B 3 ) #( $C $E 12 ) #( $D $C 3 )
            #( $D $E 2 ) #( $D $F 6 ) #( $E $F 1 ) ).
dijkstra nodes: nodes.
dijkstra
	edges: edges
	from: #first
	to: #second
	weight: #third.

shortestPathAToB := dijkstra runFrom: $A to: $B.
pathDistanceAToB := (dijkstra findNode: $B) pathDistance.

dijkstra end: $F.
shortestPathAToF := dijkstra reconstructPath.
pathDistanceAToF := (dijkstra findNode: $F) pathDistance.

dijkstra reset.
shortestPathBToE := dijkstra runFrom: $B to: $E.
]]]

!!!Shortest path on Directed Acyclic Graphs (DAG)

If the graph is a directed acyclic weighted graph (DAG), we can calculate the shortest path using an algorithm
based on topological sort. Using this algorithm we have a time complexity of {{{$O(V + E)$}}}.
This algorithm is also single source shortest path. The idea of the algorithm is to order the nodes in a
topological order, then keep tracking of the path weight of each node. Then, start poping the nodes in
topological order and store the ones with the lowest path weight. As this algorithm runs in graphs that has no cycles,
it ""can"" accept negative weights.
The pseudocode is:

[[[
1. Initialize the initial distance to every node to be infinity and the distance of the start node to be 0.
2. Create a topological order of all nodes.
3. For every node u in topological order:
- Do following for every adjacent node v of u
- IF (v pathWeight > u pathWeight + weight(u, v)) THEN v pathWeight: u pathWeight + weight(u, v)
]]]

The Pharo implementation is as follows.

[[[
AIShortestPathInDAG>>#run

	| topSorter stack sortedNode |
	self initializePathWeights.
	topSorter := AITopologicalSorting new
		             addNodesFromDifferentGraph: nodes;
		             yourself.
	topSorter run.
	"Sort the nodes in topological order"
	stack := topSorter topologicalSortedElements.
	[ stack isNotEmpty ] whileTrue: [
		sortedNode := self findNode: stack removeFirst.
		sortedNode outgoingEdges do: [ :nextEdge |
			nextEdge to pathWeight >
      (sortedNode pathWeight + nextEdge weight)
				ifTrue: [
					nextEdge to pathWeight: sortedNode pathWeight +
          nextEdge weight.
					"The previousNode variable is used for retrieving the path"
					nextEdge to previousNode: sortedNode ] ] ]
]]]

!!!!Case study

On this weighted DAG, calculate the shortest path between node A and node F.

[[[
nodes := $A to: $G.
edges := #( #( $A $B 1 ) #( $B $C 5 ) #( $B $E 11 ) #( $B $D 8 )
            #( $D $E 6 ) #( $E $F 7 ) #( $G $D 4 ) ).
shortestPathInDAG nodes: nodes.
shortestPathInDAG
	edges: edges
	from: #first
	to: #second
	weight: #third

pathAtoF := shortestPathInDAG runFrom: $A to: $F.
]]]

+DAG.>figures/dag.pdf|width=50+

!!!Shortest path on weighted graphs with negative weights (Bellman-Ford algorithm)

In the Dijkstra's algorithm when a node is marked as visited, the algorithm already found the best distance to it, because adding any positive numbers
will only increase the path distance. When we are dealing with negative numbers the assumption is not true.

The Bellman-Ford algorithm can handle negative weighted graphs. It runs in {{{$O(V*E)$}}} time. As the other algorithms of this chapter, this is also a single source
shortest path algorithm. The logic behind the algorithm is to perform at worst {{{$V-1$}}} times an edge relaxation. Relaxing an edge means to update the value of the
distance from the starting node to the node to which to edge goes. Then, run the algorithm one more time, if an edge can reduce its distance (be relaxed) means that the node
to which the edge goes is part of a negative cycle.

The algorithm works as follows:

[[[
1. Set the distance to every node to be infinity
2. Set the distance to the starting node to be 0
3. Perform V-1 times the edge relaxation
4. Run another V-1 times the edge relaxation, if an edge can be still relaxed means that is part of a negative cycle.
]]]

The Pharo implementation is:

[[[
AIBellmanFord>>#run

	start pathDistance: 0.
	self relaxEdges.
	"Run the algorithm another time to detect if any negative cycles exist.
	The only variation now is that if we can relax another time an edge,
	then means that we are part of a negative cycle. So, we put negative infinity as the path distance"
	self relaxEdgesToNegativeInfinity
]]]

[[[
AIBellmanFord>>#relaxEdges

	| anEdgeHasBeenRelaxed |
	"Relax the edges V-1 times at worst case"
	nodes size - 1 timesRepeat: [
		anEdgeHasBeenRelaxed := false.

		edges do: [ :edge |
			edge from pathDistance + edge weight < edge to pathDistance ifTrue: [
				edge to pathDistance: edge from pathDistance + edge weight.
				edge to previousNode: edge from.
				anEdgeHasBeenRelaxed := true ] ].

		"If no edge has been relaxed means that we can stop the iteration before V-1 times"
		anEdgeHasBeenRelaxed ifFalse: [ ^ self ] ]
]]]

[[[
AIBellmanFord>>#relaxEdgesToNegativeInfinity

	"This method is called after a first relaxation has occurred already.
  The algorithm is the same as the previous one but with the only difference that now if an edge can be relaxed we set the path distance
  as negative infinity because means that the edge is part of a negative cycle."

	| anEdgeHasBeenRelaxed |
	"Relax the edges V-1 times at worst case"
	nodes size - 1 timesRepeat: [
		anEdgeHasBeenRelaxed := false.

		edges do: [ :edge |
			edge from pathDistance + edge weight < edge to pathDistance ifTrue: [
				edge to pathDistance: Float negativeInfinity.
				anEdgeHasBeenRelaxed := true ] ].

		"If no edge has been relaxed means that we can stop the iteration before V-1 times"
		anEdgeHasBeenRelaxed ifFalse: [ ^ self ] ]
]]]

!!!Longest path problem

To calculate the longest path of a graph we can simply multiply all the nodes weights by {{{$-1$}}} and then
calculate the shortest path. If the graph is a DAG, then we can use the topological sort based algorithm.
If not, we can use Bellman-Ford.

!!!!Case study

+Bellman-Ford graph>figures/longest_path.pdf|width=50+

We multiply by {{{$-1$}}} the weight of the edges of the previous graph used as an example for the DAG algorithm
and then we calculate the shortest path between two nodes using the Bellman-Ford algorithm. Doing that, actually
we are calculating the longest path for the original graph.

[[[
bellmanFord := AIBellmanFord new.
nodes := $A to: $F.
edges := #( #($A $B -1) #($B $C -5) #($B $E -11)
            #($B $D -8) #($E $F -7) #($D $E -6)
            #($G $D -4) ).
bellmanFord nodes: nodes.
bellmanFord
	edges: edges
	from: #first
	to: #second
	weight: #third.

pathFromAtoF := bellmanFord runFrom: $A to: $F.
pathDistanceFromAToF := (bellmanFord findNode: $F) pathDistance
]]]

If we look at the path between ==A== and ==F==, we see == #( $A $B $D $E $F )== which is actually the longest path
of the original graph.
