!!Minimum spanning tree algorithm

The minimum spanning tree is a subset of the edges of a undirected weighted graph that connects all the nodes of the graph
without any cycles and with the total sum of the weights minimized. There are several algorithm for obtaining the minimum spanning
tree of a weighted graph, the most famous is the Kruskal's algorithm. In the case of an disconnected graph, the algorithm
returns the minimum spanning tree for each of the graph components. That is a minimum spanning forest.

!!!Disjoint-Set data structure

Also called union-find data structure, is a data structure that stores disjoints set. It provides two operation: unite
two disjoint sets into one and find if two elements belong to the same disjoint set. This data structure is used in
Kruskal's algorithm to detect if adding a new edge create a cycle in the graph.

The time complexity of both of the operations is {{{$O(a(n))$}}}. {{{$a$}}} is the amortized time complexity.  Each time that
the ==find:== method is invoked a operation called ''path compression'' is done. Thanks to the path compression operation is that
this data structure has an amortized linear time complexity.

In Pharo, this data structure represents a node in the Kruskal's graph algorithm.

[[[
AIDisjointSetNode >> union: aDSNode

	| root1 root2 |
	root1 := aDSNode find.
	root2 := self find.
	"The nodes already belong to the same component"
	root1 = root2 ifTrue: [ ^ self ].
	root1 parent: root2
]]]

[[[
AIDisjointSetNode >> find

	| root next node |
	"Find the root of the component"
	node := self.
	root := node.
	[ root = root parent ] whileFalse: [ root := root parent ].

	"Compress the path leading back to the root.
	This is the path compression operation that gives the linear amortized time complexity"
	[ node = root ] whileFalse: [
		next := node parent.
		node parent: root.
		node := next ].

	"Return the root of the component"
	^ root
]]]

!!!Kruskal's algorithm

As said above, the Kruskal's algorithm calculates the minimum spanning tree (or forest) of an undirected weighted graph.
The algorithm has a time complexity of {{{$O(V*log(E)) = O(E*log(E))$}}}. This time complexity is achieved thanks to the
Disjoint-Set data structure. This algorithm uses the Disjoint-Set data structure to check if adding an edge to the spanning
tree will create a cycle. The pseudocode is:

[[[
1. Sort edges in ascending weight.
2. Pick the smallest edge. Check if its two nodes are already unified. If they are not, unified them and include the edge to the spanning tree. Else, discard it.
3. Repeat step 2 until there are all nodes are connected.
]]]

This is the implementation of the algorithm in Pharo:

[[[
AIKruskal >> run

	| treeEdges sortedEdges |
  sortBlock := [ :e1 :e2 | e1 weight < e2 weight ].
	treeEdges := OrderedCollection new.
	nodes do: #makeSet.
	sortedEdges := edges asSortedCollection: sortBlock.
	sortedEdges
		reject: [ :edge |
			"Only join the two nodes if they don't belong to the same component"
			edge from find = edge to find ]
		thenDo: [ :edge |
			edge from union: edge to.
			treeEdges add: edge ].
	^ treeEdges
]]]

!!!Kruskal's algorithm for maximum spanning tree

This is exactly the same algorithm except that we have to order the edges in descending weight instead of ascending.
[[[
1. Sort edges in descending weight.
2. Pick the biggest edge...
]]]

In the implementation we only need to change one line:
[[[
sortBlock := [ :e1 :e2 | e1 weight > e2 weight ].
]]]

!!!Case study

Imagine that you have a telecommunications company and you want to build a connection between different neighbourhoods.
Some of the connections are more expensive than others. For example, one connection has to pass under the ground or above some mountains.
So, you have a graph in which the nodes represent the different neighbourhoods and the edges represent all the
possible cables that can be built to make the connections between the neighbourhoods. The weights represent the cost of
actually building the connection.

+Connections costs between neighbourhoods>figures/kruskal.pdf|width=55+

So, like in the other graph algorithms we only need to declare the nodes and the edges an then call the method ==run==
to obtain the result.

[[[
nodes := $A to: $J.
edges := #( #( $A $B 25 ) #( $A $D 8 ) #( $A $F 11 ) #( $B $A 25 )
            #( $B $E 1 ) #( $B $C 12 ) #( $C $B 12 ) #( $C $D 16 )
            #( $C $F 6 ) #( $C $G 9 ) #( $D $A 8 ) #( $D $C 16 )
            #( $E $B 1 ) #( $E $G 14 ) #( $F $A 11 ) #( $F $C 6 )
            #( $F $G 5 ) #( $F $J 4 ) #( $G $F 5 ) #( $G $C 9 )
            #( $G $E 14 ) #( $G $H 7 ) #( $H $G 7 ) #( $I $J 7 )
            #( $J $F 4 ) #( $J $I 7 ) ).
kruskal := AIKruskal new.
kruskal nodes: nodes.
kruskal
	edges: edges
	from: #first
	to: #second
	weight: #third.
minimumSpanningTree := kruskal run
]]]

If we inspect the ==minimumSpanningTree== variable, we get a collection the edges of the minimum spanning tree.
''DSN'' means ''DisjointSetNode''.

[[[
DSN $B -> DSN $E weight: 1
DSN $J -> DSN $F weight: 4
DSN $F -> DSN $G weight: 5
DSN $F -> DSN $C weight: 6
DSN $I -> DSN $J weight: 7
DSN $H -> DSN $G weight: 7
DSN $A -> DSN $D weight: 8
DSN $A -> DSN $F weight: 11
DSN $C -> DSN $B weight: 12
]]]

+Minimum spanning tree>figures/minimum_spanning_tree.pdf|width=55+

If we want to obtain the maximum spanning tree, we only need to call the ==maxSpanningTree== method
when creating the graph algorithm.
[[[
kruskal := AIKruskal new maxSpanningTree.
]]]
