!!Shortest path problem

The shortest path problem consists on finding a path between two pais of nodes in which the sum
of the weights is minimized. For a general graph this problem is NP-hard. For some kind of graphs this problem
can be solved in linear time.

!!!Shortest path on unweighted graphs

If the graph is unweighted or all edges have the same ""non-negative"" weight, the shortest path can be found
in linear time {{{$O(V + E)$}}} using Breadth First Search (BFS) algorithm. BFS algorithm travels the graph in a traversal way.
BFS is a single source shortest path algorithm. That means that before running the algorithm if needed
to specify a starting node. Then, the algorithm can tell us the shortest path between the starting node
and all the other nodes.

[[[
initialize a queue Q
mark start node as visited
Q.enqueue(start)
while Q is not empty do:
  node := Q.dequeue()
  if node is the end then:
    return node
  for adjacent nodes of node do:
    if adjacentNode is not visited then:
      mark adjacentNode as visited
      Q.enqueue(adjacentNode)
]]]

In the Pharo implementation we use a linked list as a queue.

[[[
AIBFS>>#run

	| node neighbours |
	queue := LinkedList with: start.
	start visited: true.

	[ queue isNotEmpty ] whileTrue: [
		node := queue removeFirst.
		neighbours := node adjacentNodes.

		neighbours do: [ :next |
			next visited ifFalse: [
				queue addLast: next.
				next visited: true.
				next previousNode: node ] ] ]
]]]

After running the algorithm, to reconstruct the shortest path between the start and the end
node, we use the following method:

[[[
AIBFS>>#reconstructPath

	| path previous |
	"If no path exists between the start and the end node"
	end previousNode ifNil: [ ^ #(  ) ].
	path := LinkedList empty.
	previous := end.
	path addFirst: end model.
	[ previous = start ] whileFalse: [
		previous := previous previousNode.
		path addFirst: previous model ].
	^ path
]]]

!!!!Case study

+BFS graph>figures/bfs.pdf|width=45+

For the BFS graph, the shortest path can be calculated using the class ==AIBFS== like shown in the following example.

[[[
nodes := $a to: $i.
edges := #( #( $a $b ) #( $b $c ) #( $c $d ) #( $d $e ) #( $e $a )
            #( $b $e ) #( $e $b ) #( $e $f ) #( $f $g ) #( $g $h )
            #( $h $f ) #( $g $i ) #( $i $g ) ).
bfs := AIBFS new.
bfs
	nodes: nodes;
	edges: edges from: #first to: #second.
path := bfs runFrom: $a to: $g
]]]

The ==path== variable constains all the nodes that are part of the path, if we inspect the variable we see:
[[[
($a $b $e $f $g)
]]]

If we want to get the shortest path between the same starting node A and some other node, there is no need
of re-running the algorithm. We only need to change the end node and call the method reconstruct path.

[[[
bfs end: $d.
pathToD := bfs reconstructPath
]]]

!!!Shortest path on weighted graphs

The Dijkstra's algorithm is one of the most-know algorithms for calculating the shortest path in a weighted graph.
As BFS, this algorithm is also a single source shortest path algorithm. In its naive implementation has a time
complexity of{{{$O(V^2)$}}}. But, it can be optimized using a head or a tree as a data structure to a time
complexity of {{{$O((V+E)*log V)$}}}. If a Fibonacci heap is used we can the best possible time complexity
{{{$O(E + V * log V)$}}}. Dijkstra's algorithm can handle a graph with cycles. But, it cannot handle negative weights.

The algorithm idea is:

[[[
1. Mark all nodes as unvisited.
2. Assign to every node infinity as the distance value. Set it to zero for the initial. Set the initial node as current.
3. Consider all of unvisited neighbours of the current node and calculate their distances through the current node. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one.
4. When all of the unvisited neighbours of the current node are checked, mark the current node as visited.
5. Select the unvisited node that is marked with the smallest tentative distance, set it as the new "current node", and go back to step 3.
]]]

Selecting the unvisited node with the smallest distance is the part of the algorithm that can improve or worsen the time complexity.
Depending on the data strcuture that is chosen. If we choose an array, the time complexity is the biggest one.

The implementation in Pharo is the following:

TO BE DONE. I HAVE TO FIX THIS ALGO

!!!!Case study

+Dijkstra graph>figures/dijkstra.pdf|width=50+

In this graph, the shortest path between node A and B is ==#( $A $C $B )==
The shortest path between node A and node F is ==#( $A $C $B $D $E $F )==

[[[
nodes := $A to: $F.
edges := #( #( $A $B 5 ) #( $A $C 1 ) #( $B $C 2 ) #( $B $E 20 )
            #( $B $D 3 ) #( $C $B 3 ) #( $C $E 12 ) #( $D $C 3 )
            #( $D $E 2 ) #( $D $F 6 ) #( $E $F 1 ) ).
dijkstra nodes: nodes.
dijkstra
	edges: edges
	from: #first
	to: #second
	weight: #third
shortestPathAToB := dijkstra runFrom: $A to: $B.
shortestPathAToF := dijkstra runFrom: $A to: $F.
]]]

!!!Shortest path on Directed Acyclic Graphs (DAG)

If the graph is a directed acyclic weighted graph (DAG), we can calculate the shortest path using an algorithm
based on topological sort. Using this algorithm we have a time complexity of {{{$O(V + E)$}}}.
This algorithm is also single source shortest path. The idea of the algorithm is to order the nodes in a
topological order, then keep tracking of the path weight of each node. Then, start poping the nodes in
topological order and store the ones with the lowest path weight. As this algorithm runs in graphs that has no cycles,
it ""can"" accept negative weights.
The pseudocode is:

[[[
1. Initialize the initial distance to every node to be infinity and the distance of the start node to be 0.
2. Create a topological order of all nodes.
3. For every node u in topological order:
- Do following for every adjacent node v of u
- IF (v pathWeight > u pathWeight + weight(u, v)) THEN v pathWeight: u pathWeight + weight(u, v)
]]]

The Pharo implementation is as follows.

[[[
AIShortestPathInDAG>>#run

	| topSorter stack sortedNode |
	self initializePathWeights.
	topSorter := AITopologicalSorting new
		             addNodesFromDifferentGraph: nodes;
		             yourself.
	topSorter run.
	"Sort the nodes in topological order"
	stack := topSorter topologicalSortedElements.
	[ stack isNotEmpty ] whileTrue: [
		sortedNode := self findNode: stack removeFirst.
		sortedNode outgoingEdges do: [ :nextEdge |
			nextEdge to pathWeight >
      (sortedNode pathWeight + nextEdge weight)
				ifTrue: [
					nextEdge to pathWeight: sortedNode pathWeight +
          nextEdge weight.
					"The previousNode variable is used for retrieving the path"
					nextEdge to previousNode: sortedNode ] ] ]
]]]

!!!!Case study

On this weighted, calculate the shortest path between node A and node F.

+DAG>figures/dag.pdf|width=50+

!!!Shortest path on weighted graphs with negative weights

As the Dijkstra's algorithm always tries to minimize the distance, if the graph has negative weights then it will enter
into an infinity cycle. The Bellman-Ford algorithm handles graphs with negative weights. Like all the other previous algorithms,
this is also single source shortest path. It has a time complexity of {{{$O(V * E)$}}}.

NEEDS TO BE COMPLETED BECAUSE THE BELLMAN-FORD ALGO WAS NOT PRESENT IN THE PREVIOUS LIBRARY AND I DID NOT IMPLEMENTED YET.

!!!!Case study

+Bellman-Ford graph>figures/bellman_ford.pdf|width=50+

!!!Longest path problem

To calculate the longest path of a graph we can simply multiply all the nodes weights by {{{$-1$}}} and then
calculate the shortest path. If the graph is a DAG, then we can use the topological sort based algorithm.
If not, we can use Bellman-Ford.
