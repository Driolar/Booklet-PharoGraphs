!!Representation

So far the graphs were represented as drawings. But, to program them a data structure is needed. The most used data structures to represent graphs are:
- An adjacency Matrix
- An Adjacency List

In this library the adjacency list is the data structure that is used.

!!!Graph algorithms

All the different graph algorithms of this library have a common API. All the algorithms are
subclasses of ==AIGraphAlgorithm==. The class ==AIGraphAlgorithm== provides the common API to add nodes, edges, searching the nodes, etc.

+Class diagram>figures/uml.pdf|width=30+

For example, to creating a graph, you can use the methods ==nodes:== and ==edges:from:to:==

[[[
| graph |
graph := AIGraphAlgorithm new.
graph nodes: #( $A $B $C ).
graph edges: #( #( $A $B ) #( $A $C ) #( $B $C ) )
  from: #first
  to: #second.
graph run.
]]]

First, we instantiate the graph algorithm (in this case the abstract one). Then, instantiate the nodes. And finally, set the edges.
Note that for the edges we need to pass a list. The elements inside a list can be any kind of object. In the above example
the objects are also a list. And then, we need to specific a block that is needed to obtain
the ==from:== and ==to:== relationships. In the example, the ''in node'' is the first element
of the list and the second one is the ''out node''. So, we need only to send the messages ==first== and ==second==.

To represent weighted graphs we use the ==edges:from:to:weight:== method.

[[[
| graph |
graph := AIGraphAlgorithm new.
graph nodes: #( $A $B $C ).
graph edges: #( #( $A $B 2 ) #( $A $C 4 ) #( $B $C 7 ) )
  from: #first
  to: #second
  weight: #third.
graph run.
]]]

So in this case the library is going to take the third element as the weight for each of the edges.
